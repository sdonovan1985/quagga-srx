/**
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of
 * their official duties. Pursuant to title 17 Section 105 of the United
 * States Code this software is not subject to copyright protection and
 * is in the public domain.
 * 
 * NIST assumes no responsibility whatsoever for its use by other parties,
 * and makes no guarantees, expressed or implied, about its quality,
 * reliability, or any other characteristic.
 * 
 * We would appreciate acknowledgment if the software is used.
 * 
 * NIST ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION AND
 * DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING
 * FROM THE USE OF THIS SOFTWARE.
 * 
 * 
 * This software might use libraries that are under GNU public license or
 * other licenses. Please refer to the licenses of all libraries required 
 * by this software.
 *
 * The update cache holds the updates in two separate structures, one is the 
 * update cache, a hash table with the update id as key and the update as 
 * value. The other is a list, that allows to scan through all updates. Both 
 * MUST be maintained the same.
 * 
 * @version 0.4.0.1
 *
 * Changelog:
 * -----------------------------------------------------------------------------
 * 0.4.0.1  - 2016/07/02 - oborchert
 *            * Removed misleading error message. The system generated an error
 *              for each update that could not be stored a second time. 
 *              Duplicates will not be stored - correct behavior and therefore I
 *              removed the misleading message.
 * 0.4.0.0  - 2016/06/19 - oborchert
 *            * Updated the collisionDetection method to conform with the 
 *              algorithm within the id generation.
 * 0.3.0.10 - 2015/11/09 - oborchert
 *            * Removed types.h
 *            * Removed unused variables.
 * 0.3.0    - 2012/12/31 - oborchert
 *            * Added XML print function
 *          - 2012/12/17 - oborchert
 *            * Changed the logic of function getUpdateResult's signature. Both,
 *              result and default value are out parameters now. 
 * 0.2.0    - 2011/11/01 - oborchert
 *            * mostly rewritten
 * 0.1.0    - 2010/04/15 - pgleichm
 *            * Code created.
 */

#include <uthash.h>
#include <stdbool.h>
#include <stdint.h>
#include <malloc.h>
#include <time.h>
#include "server/update_cache.h"
#include "server/server_connection_handler.h"
#include "server/prefix_cache.h"
#include "shared/srx_defs.h"
#include "shared/srx_packets.h"
#include "util/log.h"
#include "util/prefix.h"
#include "util/xml_out.h"
#include "util/mutex.h"

/* Number of preallocated result slots */
//#define NUM_PREALLOC  20
#define NUM_PREALLOC  1

#define HDR "([0x%08X] UpdateCache): "

/**
 * A single update result.
 */
typedef struct {
  uint8_t* clients;           // clients with value 0 are unused.
  uint8_t  noPossibleClients; // maximum number of clients in list without 
                              // extending
  
  SRxUpdateID      updateID;  // the unique update ID.
  
  UT_hash_handle   hh;            // The hash table where this entry is stored 
                                  // in
  uint32_t         asn;           // The Origin AS of this update
  IPPrefix         prefix;        // The prefix of this update
  SRxResult        srxResult;     // The result generated by SRx
  SRxDefaultResult defaultResult; // The result provided by verification 
                                  // request.
  uint32_t         roaRefCount;   // the number of ROA's that cover this update

  uint16_t         gcFlag;        // Indicates when this entry can be deleted
                                  // by the garbage collector.
  
  uint32_t         blobLength;    // The length of the update blob
  uint8_t*         blob;          // The update blob itself.
} CacheEntry;

// Forward declarations
bool _addClientReference(UpdateCache* self, CacheEntry* cEntry, 
                         uint8_t clientID, ProxyClientMapping* clientMapping);
uint16_t getGCTime(uint16_t keepTime);

/**
 * This function selects the data from bgpsecData that is used for ID generation
 * - see srx_identifier::generateIdentifier and stores it in the cache entry.
 * It is important that both data blobs are same otherwise problems with the
 * ID finding are given.
 * This method copies the data from bgpsecData into the cache entry. Therefore
 * the memory allocated in bgpsecData can safely be deallocated.
 * 
 * @param cEntry The cache entry where the blob data will be stored in.
 * @param bgpsecData The bgpsec (and bgp4) data that has to be stored.
 * 
 * @return false if the cache entry already contains data,otherwise true.
 * 
 * @since 0.4.0.0 
 * 
 * @see srx_identifier.h::generateIdentifier
 */
bool storeCacheEntryBlob(CacheEntry* cEntry, BGPSecData* bgpsecData)
{
  bool retVal = false;
  
  if (cEntry->blob == NULL)
  {
    if (bgpsecData->attr_length != 0)
    {
      cEntry->blobLength = bgpsecData->attr_length;
      cEntry->blob = malloc(cEntry->blobLength);
      if (cEntry->blob != NULL)
      {
        memcpy(cEntry->blob, bgpsecData->bgpsec_path_attr, cEntry->blobLength);
        retVal = true;
      }
    }
    else
    {
      cEntry->blobLength = bgpsecData->numberHops * 4;
      cEntry->blob = malloc(cEntry->blobLength);
      if (cEntry->blob != NULL)
      {
        memcpy(cEntry->blob, bgpsecData->asPath, cEntry->blobLength);
        retVal = true;
      }
    }
  }
  
  return retVal;
}

/*---------------------
 * Hash-table functions
 *
 * @note Uses R/W lock
 */
/**
 * This method searches the cache for the update with the given update id.
 * if found the result is written into the out pointer.
 * 
 * @param self The reference for the update cache
 * @param updateID The update ID to search for.
 * @param out the cache entry containing the update in case it was found.
 * 
 * @return true if the update was found, otherwise false.
 */
static bool tableFind(UpdateCache* self, SRxUpdateID updateID, CacheEntry** out) 
{
  acquireReadLock(&self->tableLock);
  HASH_FIND(hh, (CacheEntry*)self->table, &updateID, sizeof(SRxUpdateID), 
            (*out));
  unlockReadLock(&self->tableLock);

  return (*out != NULL);
}

/**
 * Add the update encapsulated in the cache entry element into the cache. The 
 * key is the updateID and the value is the cache entry containing the update 
 * information.
 * 
 * @param self the update cache.
 * @param cEntry the update to be stored.
 */
static void tableAdd(UpdateCache* self, CacheEntry* cEntry) 
{
  acquireWriteLock(&self->tableLock);
  HASH_ADD(hh, *((CacheEntry**)&self->table), updateID, sizeof(SRxUpdateID), 
           cEntry);
  unlockWriteLock(&self->tableLock);
}

/**
 * Remove the update entry from the update cache. This method does NOT release
 * the memory attached to the cache entry!!!
 * 
 * @param self The update cache.
 * @param cEntry the entry containing the update information.
 */
static void tableDel(UpdateCache* self, CacheEntry* cEntry) 
{
  acquireWriteLock(&self->tableLock);
  HASH_DEL(*((CacheEntry**)&self->table), cEntry);
  unlockWriteLock(&self->tableLock);
}  

/*--------
 * Exports
 */

/**
 * Initialized the update cache. The memory for the cache MUST be allocated
 * by the caller of this method.
 * 
 * @param self The update cache
 * @param chCallback The callback method executed for changes within the cache
 * @param minNumberOfUpdates the minimum number of expected clients. Must be
 *                           greater then 0;
 * 
 * @return 
 */
bool createUpdateCache(UpdateCache* self, UpdateResultChanged chCallback, 
                       uint8_t minNumberOfUpdates, Configuration* sysConfig) 
{
  if (!initMutex(&self->itemMutex)) 
  {
    RAISE_ERROR("Unable to setup the item Mutex");
    return false;
  }
  if (!createRWLock(&self->tableLock)) 
  {
    RAISE_ERROR("Unable to setup the hash table r/w lock");
    releaseMutex(&self->itemMutex);
    return false;
  }

  self->resChangedCallback = chCallback;
  // By default keep the hashtable null, it will be initialized with the first 
  // element that will be added.
  self->table = NULL;
  self->itemsUsed = NUM_PREALLOC;
  self->minNumberOfClients = DEFAULT_NUMBER_CLIENTS;
  self->lockedClients = malloc(MAX_PROXY_CLIENT_ELEMENTS);
  memset(self->lockedClients, false, MAX_PROXY_CLIENT_ELEMENTS);
  
  self->sysConfig = sysConfig;
    
  initSList(&self->allItems);

  return true;
}

//TODO: Documentation
void releaseUpdateCache(UpdateCache* self) 
{
  RAISE_ERROR("Release Update Cache also should empty the cache first!");
  if (self != NULL) 
  {
    releaseRWLock(&self->tableLock);
    releaseMutex(&self->itemMutex);

    // Empty cache first
    emptyUpdateCache(self);
    free(self->lockedClients);
    releaseSList(&self->allItems);
  }
}

/**
 * Queries the update cache for the result associated with the update. This
 * method DOES NOT create a cache entry if no update was found. This method DOES
 * NOT change the update cache in any means. If already stored updates contain
 * SRx_RESULT_UNDEFINED as roa or bgpsec result, this result will be exchanged
 * with the default value.
 *
 * @param self The instance of the update cache
 * @param updId The update ID whose result is queried
 * @param clientID The id of the client that requests the update result.
 *                 in case the ID is greater than zero "> 0" the client will be
 *                 registered with the update, Otherwise it will not be 
 *                 registered.
 * @param client   The proxy client. MUST be NULL if clientID == 0.
 * @param srxRes The current result associated with the update This is an OUT
 *               parameter. 
 * @param defResult The default result provided by proxy during verification
 *                  call. This is an OUT parameter.
 *
 * @return true if the update was found, false if not.
 */
bool getUpdateResult(UpdateCache* self, SRxUpdateID* updateID, 
                     uint8_t clientID, void* clientMapping, 
                     SRxResult* srxRes, SRxDefaultResult* defaultRes)
{
  // The cache entry also need the addition of source and predefined result.
  CacheEntry* cEntry = NULL;
  // By default declare the update as not found
  bool retVal = false;
  // This seems to be silly at this point but it might be that the id will 
  // become MD5 or even more. For this we accept a pointer to the structure
  // but store it as value only. See documentation for SRxUpdateID for more info
  SRxUpdateID updID = *updateID;

  // Look for the update
  if (tableFind(self, updID, &cEntry)) 
  {
    // Prefix Origin values
    srxRes->roaResult               = cEntry->srxResult.roaResult;
    defaultRes->resSourceROA        = cEntry->defaultResult.resSourceROA;
    defaultRes->result.roaResult    = cEntry->defaultResult.result.roaResult;

    // Path Validation values
    srxRes->bgpsecResult            = cEntry->srxResult.bgpsecResult;
    defaultRes->resSourceBGPSEC     = cEntry->defaultResult.resSourceBGPSEC;
    defaultRes->result.bgpsecResult = cEntry->defaultResult.result.bgpsecResult;
    
    if (clientID > 0)
    {
      // Register the update with the client!
      _addClientReference(self, cEntry, clientID, 
                          (ProxyClientMapping*)clientMapping);
    }
    
    retVal = true;
  }
  else
  {
    srxRes->roaResult               = SRx_RESULT_UNDEFINED;
    defaultRes->resSourceROA        = SRxRS_DONOTUSE;
    defaultRes->result.roaResult    = SRx_RESULT_DONOTUSE;

    // Path Validation values
    srxRes->bgpsecResult            = SRx_RESULT_UNDEFINED;
    defaultRes->resSourceBGPSEC     = SRxRS_DONOTUSE;
    defaultRes->result.bgpsecResult = SRx_RESULT_DONOTUSE;
  }

  return retVal;
}

/**
 * Assign the given client to the cache entry. This method extends the memory
 * if needed.
 * 
 * @param cEntry The cache entry containing the update
 * @param clientID The client assigned to the update.
 * 
 * @return true if the client is attached!
 */
bool _addClientReference(UpdateCache* self, CacheEntry* cEntry, 
                         uint8_t clientID, ProxyClientMapping* clientMapping)
{
  bool added = false;
  int idx;
  
  if (clientID == 0)
  {
    RAISE_SYS_ERROR("Invalid client ID %d added to the Update Cache for Update"
                    "[0x%08X]!!!", clientID, cEntry->updateID);
  }
  
  // Try to find then ext empty spot.
  for (idx = 0; idx < cEntry->noPossibleClients; idx++)
  {
    if (cEntry->clients[idx]==0)
    {
      cEntry->clients[idx] = clientID;      
      //TODO: depending on the final GC implementation if the GC uses a delete
      //      list, remove this cEntry from there in case gcFlag > 0
      // Increase the update count of this client
      clientMapping->updateCount++;
      added = true;
      break;
    }
    else if (cEntry->clients[idx]==clientID)
    {
      added = true;
      break;      
    }
  }
    
  if (added)
  {
    cEntry->gcFlag       = 0; // Reset the GC flag
  }
  else
  { // run out of memory, increase the array list
    // TODO: Maybe set a counter flag in UpdateCahce. this flag
    // could be used to automatically increase the minimum number of clients
    // by 2 or the default value for future updates. A minimum threshold could
    // be 1000 extensions or even configured?
    
    int newSize = cEntry->noPossibleClients + self->minNumberOfClients;
    cEntry->clients = realloc(cEntry->clients, newSize);
    
    if (cEntry->clients)
    {
      for (idx = cEntry->noPossibleClients; idx < newSize; idx++)
      { // initialize with zero "0"
        cEntry->clients[idx] = (uint8_t)0;
      }
      // Now add the new client
      cEntry->clients[cEntry->noPossibleClients] = clientID;
      cEntry->noPossibleClients = (uint8_t)newSize;
      added = true;
    }
    else
    {
      RAISE_SYS_ERROR("Extending client memory for Update[0x%08X] failed!!",
                      cEntry->updateID);
    }
  }
  
  return added;
}

/**
 * Stores an update in the update cache. This method returns 0 in case the 
 * update already exists in the update cache. In this case depending on the 
 * operational flow the stored update should be re-queried. This might happen
 * if two clients request the same update information at the exact same time 
 * and both will receive information that the update is not stored yet. In this
 * case both might attempt to store the update. Here it is important to notice 
 * that the default value might differ. The caller where the result is 0 should
 * re-query the result to assure the returned validation result is same.
 * In case the result value is 1 the provided update was stored successfully.
 * for internal errors the result value is -1. For the update result the value
 * SRX_RESULT_UNDEFINED is used to indicate that the validation was not 
 * performed yet. As long as the value is UNDEFINED the command handler accepts
 * a validation request for this particular update. Once the value is other than
 * "UNDEFINED" a validation attempt will be stopped. From this moment the RPKI-
 * Handler and BGPSEC-handler are the only two instances that can start a new
 * validation.
 * 
 *
 * @param self The instance of the update cache.
 * @param clientID The ID of the srx-server client. This is NOT the proxyID,
 *                 it is a one byte client ID that is mapped to the proxyID.
 * @param clientMapping The mapping entry for the client.
 * @param updateID The ID of the Update.
 * @param prefix The prefix of the update.
 * @param asn    The AS number of the update.
 * @param defRes The default result info. This will only be taken when stored
 *               the very first time. In case the value is NULL for a first time
 *               storage, the internal UNDEFINED and UNKNOWN will be used.
 * @param bgpSec Contains BGPSEC data. This parameter as well as defRes is only
 *               used during initial storing of an update. The value can be 
 *               NULL.
 * 
 *
 * @return 1 the result stored, 0 the update is already stored, 
 *         -1 indicates an internal error
 */
int storeUpdate(UpdateCache* self, uint8_t clientID, void* clientMapping,
                SRxUpdateID* updateID, IPPrefix* prefix, uint32_t asn, 
                SRxDefaultResult* defRes, BGPSecData* bgpSec)
{
  CacheEntry* cEntry;
  
  int retVal = 1; // by default report it worked
  
  // This seems to be silly at this point but it might be that the id will 
  // become MD5 or even more. For this we accept a pointer to the structure
  // but store it as value only. See documentation for SRxUpdateID for more info
  SRxUpdateID updID = *updateID;

  LOG(LEVEL_DEBUG, HDR "Store update [ID:0x%08X] in update cache.", 
                   pthread_self(), updID);
  
  // Existing entry then only update the result values.
  if (tableFind(self, updID, &cEntry))
  {
    LOG(LEVEL_WARNING, "Attempt to store an update that already exists in "
                       "update cache!");
    retVal = 0;
  }
  else
  {
    // The update will be stored in two phases, first it will be stored in the 
    // update list that is accessible from outside. The the update information 
    // will be stored in the hash table.    
    
    // Store a brand new update in the list
    // New entry
    lockMutex(&self->itemMutex);

    if (self->itemsUsed == NUM_PREALLOC) 
    {
      // In case the pre-allocated empty space is used up, create more. 
      self->availItems = appendToSList(&self->allItems, 
                                       sizeof(CacheEntry) * NUM_PREALLOC);
      if (self->availItems == NULL) 
      {
        return -1;
      }
      self->itemsUsed = 0;
    }

    // now get the new accessible space.
    cEntry = (CacheEntry*)(self->availItems 
                           + (self->itemsUsed * sizeof(CacheEntry)));
    // mark the entry as used for now.
    self->itemsUsed++; 
    
  //    unlockMutex(&self->itemMutex);
    
    cEntry->updateID      = updID;
    cEntry->asn           = asn;
    cpyPrefix(&cEntry->prefix, prefix);
    cEntry->srxResult.bgpsecResult = SRx_RESULT_UNDEFINED;
    cEntry->srxResult.roaResult    = SRx_RESULT_UNDEFINED;
    
    if (defRes != NULL)
    {
      cEntry->defaultResult.result.roaResult    = defRes->result.roaResult;
      cEntry->defaultResult.result.bgpsecResult = defRes->result.bgpsecResult;
      cEntry->defaultResult.resSourceROA        = defRes->resSourceROA;
      cEntry->defaultResult.resSourceBGPSEC     = defRes->resSourceBGPSEC;
    }
    else
    {
      cEntry->defaultResult.result.roaResult    = SRx_RESULT_UNDEFINED;
      cEntry->defaultResult.result.bgpsecResult = SRx_RESULT_UNDEFINED;
      cEntry->defaultResult.resSourceROA        = SRxRS_UNKNOWN;
      cEntry->defaultResult.resSourceBGPSEC     = SRxRS_UNKNOWN;      
    }
    // Other Update relates data        
    // BGPSEC
    if (bgpSec != NULL)
    {
      //TODO: see BZ197 - this cases once a while a SEGDEV
      if (!storeCacheEntryBlob(cEntry, bgpSec))
      {
        // Actually we end up here when the element exists already in the cache.
        // It is not an error. BZ 1010
      }
    }
    else
    {
      cEntry->blobLength = 0;
      cEntry->blob = NULL;
    }    

    // Add the client ID to the update
    int memsize = sizeof(uint8_t) * self->minNumberOfClients;
    cEntry->clients = malloc(memsize);
    memset(cEntry->clients, 0, memsize);
    cEntry->noPossibleClients = self->minNumberOfClients;
    
    // ClientID might be zero "0" is the request is store only - This should not
    // be the norm. updates with zero clients will be subject to garbage 
    // collection after a while.
    if (clientID > 0)
    {
      if (!_addClientReference(self, cEntry, 
                               clientID, (ProxyClientMapping*)clientMapping))
      {
        retVal = -1;
        RAISE_SYS_ERROR("ERROR assigning client to update!!!");
        // TODO: maybe remove the entry from the list!!!
      }
    }
    else
    {
      // Mark for GC
      uint16_t keepWindow = (uint16_t)self->sysConfig->defaultKeepWindow;
      cEntry->gcFlag = getGCTime(keepWindow);
    }
    
    // Finally add the entry to cache.
    tableAdd(self, cEntry);

    unlockMutex(&self->itemMutex);  
  }
  return retVal;
}

/**
 * Stores a result for in the update cache for later retrieval.
 * If this overwrites an existing update result, then the registered 
 * UpdateResultChanged callback is called. The update MUST exist! Only result
 * values other than SRx_RESULT_DONOTUSE are used. This allows to change only 
 * one value, not necessary both.
 *
 * @param self The instance of the update cache.
 * @param updateID The ID of the Update.
 * @param result the result the current update has to be updated with. In case
 *               the result differs from the stored update result, a 
 *               notification will be send to the client. to indicate which 
 *               result MUST NOT be modified use SRx_RESULT_DONOTUSE.
 *
 * @return true the result stored, false indicates an internal error such as the
 *              update does not exist.
 */
bool modifyUpdateResult(UpdateCache* self, SRxUpdateID* updateID, 
                        SRxResult* result)
{
  CacheEntry* cEntry;
  bool retVal = true;
  // This seems to be silly at this point but it might be that the id will 
  // become MD5 or even more. For this we accept a pointer to the structure
  // but store it as value only. See documentation for SRxUpdateID for more info
  SRxUpdateID updID = *updateID;

  // Existing entry then only update the result values.
  if (!tableFind(self, updID, &cEntry))
  {
    RAISE_SYS_ERROR("Does not exist in update cache, can not modify it!");
    retVal = false;    
  }
  else
  {
    lockMutex(&self->itemMutex);    
    
    SRxValidationResult valRes;
    valRes.updateID = updID;
    valRes.valType  = 0;
    valRes.valResult.roaResult    = cEntry->srxResult.roaResult;
    valRes.valResult.bgpsecResult = cEntry->srxResult.bgpsecResult;
    //valRes.clientID		  = cEntry->clientID;
    
    // Check if ROA results can be used.
    if (result->roaResult != SRx_RESULT_DONOTUSE)
    { // // Do ROA results differ ?
      if (result->roaResult != cEntry->srxResult.roaResult)
      {
        valRes.valType |= SRX_FLAG_ROA;        
        cEntry->srxResult.roaResult = result->roaResult;
        valRes.valResult.roaResult = result->roaResult;
      }
    }
    
    // Check if BGPSEC results can be used.
    if (result->bgpsecResult != SRx_RESULT_DONOTUSE)
    { // Check for changes in bgpsec result
      if (result->bgpsecResult != cEntry->srxResult.roaResult)
      {
        valRes.valType |= SRX_FLAG_BGPSEC;        
        cEntry->srxResult.bgpsecResult = result->bgpsecResult;
        valRes.valResult.bgpsecResult = result->bgpsecResult;
      }      
    }

    // check if a validation result changed.
    if (valRes.valType != 0)
    {
      if (self->resChangedCallback != NULL)
      {
        // Notify of the change of validation result.
        self->resChangedCallback(&valRes);     
      }
      else
      {
        RAISE_ERROR("No resChangedCallback function registered! "
                    "Cannot propagate the changes in the validation result!");
        retVal = false;
      }
    }
    
    unlockMutex(&self->itemMutex);
  }
  
  return retVal;
}

/**
 * Try to finally delete the update.
 * 
 * @param self The Update cache
 * @param cEntry The cache entry (update)
 * @param pCache The prefix cache.
 * @param force  Force the deletion of the update. This ignores if the update is
 *               still referenced by clients.
 * 
 * @return true if the update was deleted, otherwise false/
 * 
 * @since 0.3.0
 */
bool gcTestAndDeleteUpdate(UpdateCache* self, CacheEntry* cEntry, 
                           void* pCache, bool force)
{
  //TODO: Test one last time if the update can be deleted. If so then delete it.
  // This method MUST be called by the garbage collector.
  LOG(LEVEL_INFO,"IMPLEMENTATION CAN BE EXPECTED WITH VERSION 0.4");
  bool delete = !force;
  
  if (!force)
  {
    // 1. CHECK IF GC TIME IS READY

    // 2. CHECK ONE MORE TIME IF NO REFERENCE EXISTS
  }
  
  if (delete)
  {
    if (!removeUpdate((PrefixCache*)pCache, &cEntry->updateID, &cEntry->prefix,
                      cEntry->asn))
    {
      // The reason might be that the update was not validated. (stored only)
      LOG(LEVEL_WARNING, "Could not delete the update 0x08X from the prefix "
                         "cache!");
    }

    // now remove it from the update cache
    // Does not release the memory but only removes the hash table entry
    tableDel(self, cEntry);
    // Now remove it from the allItems list of the cache
    deleteFromSList(&self->allItems, cEntry);

    // Free the memory of the bgpsec blob;
    free(cEntry->blob);
    // Free the cache entry.
    free(cEntry);
  }

  return delete;
}

/** 
 * Set the flag when the update can be garbage collected.
 * 
 * @param cEntry The cache entry - update
 * @param timeOfDeletion The GC time when the update can be deleted.
 */
void setGCFlag(CacheEntry* cEntry, uint16_t timeOfDeletion)
{
  cEntry->gcFlag = timeOfDeletion;
}

/**
 * Calculates a new GC time when to run.
 *
 * @param keepTime The proposed time to wait
 * 
 * @return the next time the GC can run. Notice that this timestamp is a 16 bit,
 *         NOT 32 bit number. The Garbage collector knows how to deal with 
 *         overflows
 */
uint16_t getGCTime(uint16_t keepTime)
{
  time_t nextRealTime = time(NULL) + keepTime;
  return (uint16_t)(nextRealTime);
}

/**
 * Removes the given client update reference. This method DOES NOT delete
 * the physical instance of the update, it sets the deletion flag for the 
 * garbage collector if no further reference exists.
 * 
 * @param entry the update entry within the update cache
 * @param the client that has to be removed
 * 
 * @return 0 if no further references exist, 1 for one or more existing 
 *         references, -1 no reference between client and update found!
 */
int _deleteUpdateFromCache_clientMgmt(CacheEntry* entry, uint8_t clientID)
{
  int idx;
  bool found  = false;
  bool others = false;
  
  for (idx = 0; idx < entry->noPossibleClients; idx++)
  {
    if (entry->clients[idx] == clientID)
    {
      found = true;
      entry->clients[idx] = (uint8_t)0;
    }
    else if(entry->clients[idx] != 0)
    {
      others = true;
      if (found)
      {
        // Move all clients one to the left
        if (entry->clients[idx] != 0)
        {
          entry->clients[idx-1] = entry->clients[idx];
          entry->clients[idx] = 0;
        }
        else
        {
          // can stop here
          break;
        }
      }
    }
  }
  
  return !found ? -1 : others ? 1 : 0;
}  
 
/**
 * Removes the update data from the list and releases all memory associated to 
 * it.
 * 
 * @note This method ONLY deletes the update from the update cache. It is 
 *       important to assure that other references such as the prefix_cache
 *       might be affected by this.
 *       
 * @param self The instance of the update cache 
 * @param clientID The ID of the srx-server client. This is NOT the proxyID,
 *                 it is a one byte client ID that is mapped to the proxyID.
 *                 If this id is zero all mappings and the update itself will be 
 *                 removed!
 * @param cEntry   The update itself.
 * @param timeOfDeletion A proposed real-time in seconds until the update should
 *                 be kept before final deletion. The cache might remove the 
 *                 update at any other time though.
 * 
 * @return true If the update / association could be removed, false if the 
 *              update was not either found in the cache or no association to 
 *              the client was found.
 */
int _deleteUpdateFromCache(UpdateCache* self, uint8_t clientID, 
                           CacheEntry*  cEntry, uint16_t timeOfDeletion)
{
  bool retVal = false;
  
  // Check if the entry is associated with the client that requests the 
  // deletion.
  switch (_deleteUpdateFromCache_clientMgmt(cEntry, clientID))
  {
    case -1 : // Not found
      LOG(LEVEL_INFO, "Delete aborted, update [0x%08X] not referenced to the "
                      "client (0x%20X)!", cEntry->updateID, clientID);
      retVal = false;
      break;
    case 0 : // no reference left
      setGCFlag(cEntry, timeOfDeletion);
    case 1 : // still some left, don't delete
    default:
      retVal = true;
  }

  return retVal;
}

/**
 * Removes the update data from the list and releases all memory associated to 
 * it.
 * 
 * @note This method ONLY deletes the update from the update cache. It is 
 *       important to assure that other references such as the prefix_cache
 *       might be affected by this.
 *       
 * @param self The instance of the update cache 
 * @param clientID The ID of the srx-server client. This is NOT the proxyID,
 *                 it is a one byte client ID that is mapped to the proxyID.
 *                 If this id is zero all mappings and the update itself will be 
 *                 removed!
 * @param updateID The ID of the update that has to be removed.
 * @param keepTime A proposed time in seconds the update should still be kept 
 *                 before final deletion. The cache might remove the update at 
 *                 any time though.
 * 
 * @return true If the update / association could be removed, false if the 
 *              update was not either found in the cache or no association to 
 *              the client was found.
 */
bool deleteUpdateFromCache(UpdateCache* self, uint8_t clientID, 
                           SRxUpdateID* updateID, uint16_t keepTime)
{
  CacheEntry* cEntry;
  bool retVal = false;
  // This seems to be silly at this point but it might be that the id will 
  // become MD5 or even more. For this we accept a pointer to the structure
  // but store it as value only. See documentation for SRxUpdateID for more info
  SRxUpdateID updID = *updateID;
  if (keepTime < self->sysConfig->defaultKeepWindow)
  {
    keepTime = self->sysConfig->defaultKeepWindow;
  }
  uint16_t timeToBeDeleted = getGCTime(keepTime);

  // Get the update cache entry from the update cache.
  if (tableFind(self, updID, &cEntry)) 
  {
    retVal = _deleteUpdateFromCache(self, clientID, cEntry, timeToBeDeleted);
  }
  else
  {
    LOG(LEVEL_INFO, "Delete aborted, update [0x%08X] not found!", updID);
  }
  
  return retVal;
}

/**
 * This function returns the update signature if already existent. It will NOT
 * start the signing. If no signature exists the return value is NULL
 *
 * @param self The instance of the update cache
 * @param result The result of the function call.
 * @param updateID The id of the update
 * @param prependCount the prepend count of the host AS
 * @param peerAS The peer AS
 * @param algorithm The algorithm used
 * @param complete Indicates if the complete signature block or just the
 *                 new addition will be returned.
 * @return The signature block.
 */
UpdSigResult* getUpdateSignature(UpdateCache* self, UpdSigResult* result,
                                 SRxUpdateID* updateID, uint32_t prependCount, 
                                 uint32_t peerAS, uint16_t algorithm,
                                 bool complete)
{
  ////////////////////////////////////////////////////////////////////////////// TOUCHED( ); OK ( ); NOT YET (x)
  CacheEntry* cEntry;
  // This seems to be silly at this point but it might be that the id will 
  // become MD5 or even more. For this we accept a pointer to the structure
  // but store it as value only. See documentation for SRxUpdateID for more info
  SRxUpdateID updID = *updateID;
  
  
  // Currently we do NOT support any algorithm!
  RAISE_ERROR("UPDATE SIGNATURES ARE CURRENTLY NOT SUPPORTED!");

  // Currently we by default throw an algorithm not supported error.
  // This can be overwritten by update not found. Once signing is supported
  // this will be changed.
  result->containsError   = true;
  result->errorCode       = SRXERR_ALGO_NOT_SUPPORTED;
  result->signatureLength = 0;
  result->signatureBlock  = NULL;

  // Look for the update
  if (!tableFind(self, updID, &cEntry))
  {
    LOG(LEVEL_INFO, "Update [0x%08X] not found! Can not sign it!", updID);
    result->errorCode = SRXERR_UPDATE_NOT_FOUND;
  }

  return result;
}

/**
 * This method is not for usage within the update cache management. It is 
 * mainly to allow the server console to query for update information.
 * 
 * @param self The update cache 
 * @param statistics The statistics information to be filles. The value 
 *                   updateID MUST be set and will be used to locate the update.
 * 
 * @return true if the update was found, otherwise false
 */
bool getUpdateData(UpdateCache* self, UC_UpdateStatistics* statistics)
{ 
  CacheEntry* cEntry;
  bool retVal = false;
  
  if (statistics == NULL)
  {
    RAISE_SYS_ERROR("The given statistics block is NULL!");
  }
  else if (*statistics->updateID == 0)
  {
    RAISE_SYS_ERROR("The given updaetID is 0 (INVALID ID)!");
  }
  // Look for the update
  else if (tableFind(self, *statistics->updateID, &cEntry)) 
  {
    retVal = true;
    statistics->asn                           = cEntry->asn;
    cpyPrefix(&statistics->prefix, &cEntry->prefix);
    statistics->bgpsecResult.containsError    = false;
    statistics->bgpsecResult.errorCode        = 0;
    statistics->bgpsecResult.signatureBlock   = NULL;
    statistics->bgpsecResult.signatureLength  = 0;
    statistics->defResult.resSourceROA   =cEntry->defaultResult.resSourceROA;    
    statistics->defResult.resSourceBGPSEC=cEntry->defaultResult.resSourceBGPSEC;
    statistics->defResult.result.roaResult =
                                         cEntry->defaultResult.result.roaResult;
    statistics->defResult.result.bgpsecResult = 
                                      cEntry->defaultResult.result.bgpsecResult;
    statistics->result.roaResult    = cEntry->srxResult.roaResult;
    statistics->result.bgpsecResult = cEntry->srxResult.bgpsecResult;
    statistics->roa_count           = cEntry->roaRefCount;
  }  
  return retVal;
}


void emptyUpdateCache(UpdateCache* self) 
{
  ////////////////////////////////////////////////////////////////////////////// TOUCHED( ); OK ( ); NOT YET (x); Tested ( )
  acquireWriteLock(&self->tableLock);
  lockMutex(&self->itemMutex);
  
  emptySList(&self->allItems);
  unlockMutex(&self->itemMutex);

  self->table     = NULL;
  self->itemsUsed = NUM_PREALLOC;

  unlockWriteLock(&self->tableLock);
}


/**
 * This method is used to configure the update cache in such that the minimum 
 * number of clients expected per update can be configured. the value MUST not 
 * be zero, zero values are reset to be one. This function does not change 
 * already created updates in the cache. They will be extended on an as needed
 * basis.
 * 
 * @param self the UpdateCache instance.
 * @param noClients The minimum number of clients expected per update.
 */
void setMinClients(UpdateCache* self, uint8_t noClients)
{
  self->minNumberOfClients = noClients;
}

/**
 * Fill the given array "clientIDs" with the number clientID's associated to the
 * update with the "updateID". This method will NOT initialize the given array 
 * with zero's but will fill the array without "holes". The return value is the
 * number of clientIDs filles in the array or -1 if the array is to small!
 * 
 * @param self The updateCache.
 * @param updateID pointer to the update ID.
 * @param clientIDs an initialized array of uint8_t elements.
 * @param size Size of the provided array in bytes.
 * 
 * @return the number of arrays filled in the array, -1 if the array is to 
 *         small.
 * 
 * @since 0.3.0
 */
int getClientIDsOfUpdate(UpdateCache* self, SRxUpdateID* updateID, 
                         uint8_t* clientIDs, uint8_t size)
{
  // The cache entry also need the addition of source and predefined result.
  CacheEntry* cEntry = NULL;
  int retVal = 0;
  int idx = 0;
  
  // Look for the update
  if (tableFind(self, *updateID, &cEntry)) 
  {
    if (cEntry->noPossibleClients <= size)
    {
      // Run through the list of clients and fill them in the provided 
      // array
      for (idx = 0; idx < cEntry->noPossibleClients; idx++)
      {
        if (cEntry->clients[idx] != 0)
        {
          clientIDs[retVal++] = cEntry->clients[idx];
        }
      }
    }
    else
    {
      retVal = -1;
    }    
  }
  
  return retVal;    
}

/**
 * Removed the association of the client to all updates within the cache.
 * 
 * @param self The update cache
 * @param clientID The client ID
 * @param clientMapping must be NULL for clientID == 0, otherwise not.
 * @param keepTime the keep time.
 * 
 * @return the number of update associations removed, -1 if an error occured.
 * 
 * @since 0.3.0
 */
int unregisterClientID(UpdateCache* self, uint8_t clientID, void* clientMapping,
                       uint32_t keepTime)
{
  int idsRemoved = -1;
  SListNode*  lNode;
  CacheEntry* cEntry;
  ProxyClientMapping* mapping = (ProxyClientMapping*)clientMapping;
  
  acquireWriteLock(&self->tableLock);
  lockMutex(&self->itemMutex);
  if (!self->lockedClients[clientID])
  {
    idsRemoved = 0;
    self->lockedClients[clientID]=true;
    FOREACH_SLIST(&self->allItems, lNode) 
    {
      cEntry = (CacheEntry*)lNode->data;
      if (cEntry != NULL)
      {
        if (_deleteUpdateFromCache(self, clientID, cEntry, keepTime))
        {
          idsRemoved++;
          mapping->updateCount--;
        }
      }
      if (mapping->updateCount == 0)
      {
        break;
      }      
    }
    self->lockedClients[clientID]=false;
  }
  else
  {
    LOG(LEVEL_ERROR, "Attempt to unregister clocked client[0x%02X] from update "
                     "cache!", clientID);
    
  }
  unlockMutex(&self->itemMutex);
  unlockWriteLock(&self->tableLock);  
  
  return idsRemoved;
}

/**
 * This method determines if an update with the given ID already exist. If so,
 * a collision is detected. A collision is detected if an update with the same
 * updateID already exist but the data is different.
 * 
 * @param self The Update cache
 * @param updateID Update ID to be checked!
 * @param prefix the prefix of the update
 * @param asn the Origin AS of the update
 * @param dataLength The length of the bgpsec blob
 * @param data The bgpsec data blob.
 * 
 * @return true if a collision could be detected!
 */
bool detectCollision(UpdateCache* self, SRxUpdateID* updateID, IPPrefix* prefix, 
                     uint32_t asn, BGPSecData* bgpsecData)
{
  CacheEntry* cEntry;
  bool collision = false;

  uint32_t dataLength = 0;
  uint8_t* data       = NULL;
  
  if (bgpsecData->attr_length != 0)
  {
    dataLength = bgpsecData->attr_length;
    data       = bgpsecData->bgpsec_path_attr;
  }
  else
  {
    dataLength = bgpsecData->numberHops * 4;
    data       = (uint8_t*)bgpsecData->asPath;
  }
    
  // Try to find the update itself.
  if (tableFind(self, *updateID, &cEntry)) 
  {
    // An update was found, now declare collision until it is determined that 
    // the update found is the same as the update requested.
    collision = true;
    if (cEntry->asn == asn)
    {
      if (cEntry->blobLength == dataLength)
      {
        // Now check the ip prefix first, then the data blob
        int  idx = 0;
        int  bytes = (cEntry->prefix.ip.version == 4) ? 4  : 16;
        // collision will be set true as soon as a collision is found.
        collision = false;
        while (!collision && idx < bytes)
        {
          // 1. 4 bytes of v4 and v6 overlap
          collision = (        prefix->ip.addr.v6.u8[bytes] !=
                       cEntry->prefix.ip.addr.v6.u8[bytes]);
          idx++;
        }

        idx = 0;
        // Now check the data blob - only if  not already collided
        while (!collision && idx < dataLength)
        {
          collision = (data[idx] != cEntry->blob[idx]);
          idx++;
        }
      }
    }
  }
  
  return collision;
}

////////////////////////////////////////////////////////////////////////////////
// Other Helper Functions
////////////////////////////////////////////////////////////////////////////////

/**
 * Returns a textual representation of a given IPPrefix.
 * @param prefix The IPPrefix.
 * 
 * @return The text (human readable) version of the prefix.
 *
 * @note Local, static buffer - i.e. not thread-safe!
 */
const char* ipToStr(IPAddress* ip)
{
  #define BUF_SIZE  MAX_IP_V6_STR_LEN
  static const char buf[BUF_SIZE];

  return (ip->version == 4) 
           ? ipV4AddressToStr((IPv4Address*)&ip->addr.v4, (char*)buf, BUF_SIZE)
           : ipV6AddressToStr((IPv6Address*)&ip->addr.v6, (char*)buf, BUF_SIZE);
}

////////////////////////////////////////////////////////////////////////////////
//  Print Functions
////////////////////////////////////////////////////////////////////////////////

/**
 * print the srx validation result for the particular attribute.
 * 
 * @param out The xml stream
 * @param attrName the attribute name.
 * @param result The validation result of type SRxValidationResultVal
 * @param hasNotFound the validation state NOTFOUND is accepted!
 * 
 * @return true if the validation state was accepted, otherwise false.
 * 
 * @since 0.3.0
 * 
 */
bool printXMLValResult(XMLOut* out, const char* attrName, 
                       SRxValidationResultVal result, bool hasNotFound)
{
  bool retVal = true;
  switch (result)
  {
    case SRx_RESULT_DONOTUSE : 
              addStrAttrib(out, attrName, "DO NOT USE!");
              break;
    case SRx_RESULT_UNDEFINED :
              addStrAttrib(out, attrName, "UNDEFINED!");
              break;
    case SRx_RESULT_VALID :
              addStrAttrib(out, attrName, "VALID!");
              break;
    case SRx_RESULT_INVALID :
              addStrAttrib(out, attrName, "INVALID!");
              break;
    case SRx_RESULT_NOTFOUND :
              if (hasNotFound)
              {
                addStrAttrib(out, attrName, "NOTFOUND!");
                break;
              }
    default:
              addStrAttrib(out, attrName, "?????????");
              retVal = false;
              break;
  }
  
  return retVal;
}

/**
 * Print the content of the update cache to the given file.
 * 
 * @param self the update cache
 * @param stream The file to be written into.
 * @param maxBlob The maximum number of blob bytes printed. (-1 all, 0 none, 
 *                >0 the specified number or the blob length if less.)
 * 
 * @since 0.3.0
 * 
 */
void outputUpdateCacheAsXML(UpdateCache* self, FILE* stream, int maxBlob)
{
#define CLIENT_LIST_STRING_LEN 1024
  XMLOut      out;
  SListNode*  updateListNode;
  CacheEntry* update;
  uint8_t     clIdx;
  uint8_t     noClients;
  char        clientString[CLIENT_LIST_STRING_LEN];
  memset(clientString, '\0', CLIENT_LIST_STRING_LEN);
  char*       strPtr = NULL;
  initXMLOut(&out, stream);
  openTag(&out, "update-cache");

  // Add the current gc time
  addU32Attrib(&out, "current-gc-time", getGCTime(0));          
  
  // Updates
  if (sizeOfSList(&self->allItems))
  {
    openTag(&out, "updates");
    FOREACH_SLIST(&self->allItems, updateListNode)
    {
      update = (CacheEntry*)getDataOfSListNode(updateListNode);
      openTag(&out, "update");
        addH32Attrib(&out, "update-id", update->updateID);
        // noClients contains the number of clients used during the last run.
        // the multiplicator "4" is used for the maximum space used for any 
        // client ID (3 char + comma)
        memset(clientString, '\0', noClients*4);
        noClients = 0;
        strPtr = clientString;
        for(clIdx = 0; clIdx < update->noPossibleClients; clIdx++)
        {
          if (update->clients[clIdx] != 0)
          {
            noClients++;
            if (noClients == 1)
            {
              strPtr += sprintf(strPtr, "%u", update->clients[clIdx]);
            }
            else
            {
              strPtr += sprintf(strPtr, ",%u", update->clients[clIdx]);
            }
          }
        }
        addU32Attrib(&out, "no-clients", noClients);
        if (noClients > 0)
        {
          addStrAttrib(&out, "client-list", clientString);
        }
        addU32Attrib(&out, "gc", update->gcFlag);          
        addU32Attrib(&out, "origin-as", update->asn);
        addAttrib(&out, "prefix", "%s/%u",
                  ipToStr(&update->prefix.ip), 
                  update->prefix.length);
        addIntAttrib(&out, "roa-count", update->roaRefCount);
        if (!printXMLValResult(&out, "origin-val", 
                               update->srxResult.roaResult, true))
        {
          RAISE_ERROR("Update[0%x08X] with invalid origin validation state %d", 
                      update->updateID, update->srxResult.roaResult);
        }
        if (!printXMLValResult(&out, "path-val", update->srxResult.bgpsecResult, 
                               false))
        {
          RAISE_ERROR("Update[0%x08X] with invalid path validation state %d", 
                      update->updateID, update->srxResult.bgpsecResult);
        }        
        if (!printXMLValResult(&out, "def-origin-val", 
                               update->defaultResult.result.roaResult, true))
        {
          RAISE_ERROR("Update[0%x08X] with invalid default origin validation "
                      "state %d", update->updateID, 
                      update->defaultResult.result.roaResult);          
        }
        if (!printXMLValResult(&out, "def-path-val", 
                               update->defaultResult.result.bgpsecResult, true))
        {
          RAISE_ERROR("Update[0%x08X] with invalid default path validation "
                      "state %d", update->updateID, 
                      update->defaultResult.result.bgpsecResult);          
        }        
        addIntAttrib(&out, "blob-length", update->blobLength);        
      closeTag(&out);
    }
    closeTag(&out);
  }

  closeTag(&out);
  releaseXMLOut(&out);
}

